"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9906],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(a),u=l,k=d["".concat(s,".").concat(u)]||d[u]||c[u]||i;return a?n.createElement(k,r(r({ref:t},m),{},{components:a})):n.createElement(k,r({ref:t},m))}));function u(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var p=2;p<i;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5009:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),l=(a(7294),a(3905));const i={},r="Chapter 63: Alternative I/O Models",o={unversionedId:"TOC/computer/system/tlpi/tlpi",id:"TOC/computer/system/tlpi/tlpi",title:"Chapter 63: Alternative I/O Models",description:"* I/O multiplexing (select() / poll())",source:"@site/docs/TOC/computer/system/tlpi/tlpi.md",sourceDirName:"TOC/computer/system/tlpi",slug:"/TOC/computer/system/tlpi/",permalink:"/docs/TOC/computer/system/tlpi/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The Linux Programming Interface",permalink:"/docs/category/the-linux-programming-interface"},next:{title:"Networking",permalink:"/docs/category/networking"}},s={},p=[{value:"63.1 Overview",id:"631-overview",level:2},{value:"63.1.1 Level-Triggered and Edge-Triggered Notifications",id:"6311-level-triggered-and-edge-triggered-notifications",level:3},{value:"63.1.2 Employing Nonblocking I/O with Alternative I/O models",id:"6312-employing-nonblocking-io-with-alternative-io-models",level:3},{value:"63.2 I/O Multiplexing",id:"632-io-multiplexing",level:2},{value:"63.2.4 comparison of <code>select()</code> and <code>poll()</code>",id:"6324-comparison-of-select-and-poll",level:3},{value:"Portability",id:"portability",level:4},{value:"Performance",id:"performance",level:4},{value:"63.2.5 Problems with <code>select()</code> and <code>poll()</code>",id:"6325-problems-with-select-and-poll",level:3},{value:"63.3 Signal-Driven I/O",id:"633-signal-driven-io",level:2},{value:"63.3.1 When Is &quot;I/O Possible&quot; Signaled?",id:"6331-when-is-io-possible-signaled",level:3},{value:"Terminals and pseudoterminals",id:"terminals-and-pseudoterminals",level:4},{value:"63.4 The <em>epoll</em> API",id:"634-the-epoll-api",level:2},{value:"63.4.1 Creating an <em>epoll</em> instance: <code>epoll_create()</code>",id:"6341-creating-an-epoll-instance-epoll_create",level:3},{value:"63.4.2 Modifying the <em>epoll</em> Interest List: <code>epoll_ctrl()</code>",id:"6342-modifying-the-epoll-interest-list-epoll_ctrl",level:3},{value:"63.4.3 Waiting for Events: <code>epoll_wait()</code>",id:"6343-waiting-for-events-epoll_wait",level:3}],m={toc:p};function c(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"chapter-63-alternative-io-models"},"Chapter 63: Alternative I/O Models"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"I/O multiplexing (",(0,l.kt)("inlineCode",{parentName:"li"},"select()")," / ",(0,l.kt)("inlineCode",{parentName:"li"},"poll()"),")"),(0,l.kt)("li",{parentName:"ul"},"signal-driven I/O"),(0,l.kt)("li",{parentName:"ul"},"the Linux-specific ",(0,l.kt)("em",{parentName:"li"},"epoll")," API")),(0,l.kt)("h2",{id:"631-overview"},"63.1 Overview"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. (",(0,l.kt)("inlineCode",{parentName:"li"},"select"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"poll"),")"),(0,l.kt)("li",{parentName:"ul"},"Signal-driven is a technique whereby a process requests that the kernel send it a signal when input is available or data can be written on a specified file descriptor."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("em",{parentName:"li"},"epoll")," API allows a process to monitor multiple file descriptors to see if I/O is possible on any of them.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Which technique ?"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"select and poll :",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"advantage: ",(0,l.kt)("em",{parentName:"li"},"portability")),(0,l.kt)("li",{parentName:"ul"},"disadvantage: don't scale well when monitoring large numbers of file descriptors."))),(0,l.kt)("li",{parentName:"ul"},"epoll:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"primary advantage: allows an application to efficiently monitor large numbers of file descriptors."),(0,l.kt)("li",{parentName:"ul"},"advantages over signal-driven I/O:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"avoid complexities of dealing with signals"),(0,l.kt)("li",{parentName:"ul"},"can specify the kind of monitoring that we want to perform (r/w)"),(0,l.kt)("li",{parentName:"ul"},"can select either level-triggered or edge-triggered notification"))),(0,l.kt)("li",{parentName:"ul"},"disadvantage: Linux-specific API  (OSX: kqueue)"))),(0,l.kt)("li",{parentName:"ul"},"signal-driven I/O")))),(0,l.kt)("h3",{id:"6311-level-triggered-and-edge-triggered-notifications"},"63.1.1 Level-Triggered and Edge-Triggered Notifications"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Level-triggered notification: A file descriptor is considered to be ready if it is possible to perform an I/O system call without blocking."),(0,l.kt)("li",{parentName:"ul"},"Edge-triggered notification: Notification is provided if there is I/O activity (e.g. new input) on a file descriptor since it was last monitored .")),(0,l.kt)("p",null,"Use of level-triggered and edge-triggered notification models"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"center"},"I/O model"),(0,l.kt)("th",{parentName:"tr",align:"center"},"Level-triggered ?"),(0,l.kt)("th",{parentName:"tr",align:"center"},"Edge-triggered"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("inlineCode",{parentName:"td"},"select()"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"poll()")),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("span",{parentName:"td",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mo",{parentName:"mrow"},"\u2219")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\bullet")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4445em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2219")))))),(0,l.kt)("td",{parentName:"tr",align:"center"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Signal-driven I/O"),(0,l.kt)("td",{parentName:"tr",align:"center"}),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("span",{parentName:"td",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mo",{parentName:"mrow"},"\u2219")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\bullet")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4445em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2219"))))))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"epoll"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("span",{parentName:"td",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mo",{parentName:"mrow"},"\u2219")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\bullet")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4445em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2219")))))),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("span",{parentName:"td",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mo",{parentName:"mrow"},"\u2219")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\bullet")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4445em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2219"))))))))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"level-triggered: check readiness of a file descriptor at any time. not necessary to perform as much I/O as possible. (e.g., read as many bytes as possible)."),(0,l.kt)("li",{parentName:"ul"},"edge-triggered: only when an I/O event occurs."),(0,l.kt)("li",{parentName:"ul"},"should-at some point (but may starve other fd when perform a large number of I/O on one fd) -perform as much I/O as possible (e.g., read as many bytes as possible) on the corresponding file descriptor."),(0,l.kt)("li",{parentName:"ul"},"would not be aware of the need to operate on the fd until another I/O event occured."),(0,l.kt)("li",{parentName:"ul"},"could lead to spurious data loss or blockages"),(0,l.kt)("li",{parentName:"ul"},"will block I/O system call when no more I/O if it's a loop to perform as much I/O as possible on the fd and marked as blocking")),(0,l.kt)("h3",{id:"6312-employing-nonblocking-io-with-alternative-io-models"},"63.1.2 Employing Nonblocking I/O with Alternative I/O models"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"nonblocking I/O is usually employed in conjunction with I/O models that provide edge- triggered notification of I/O events"),(0,l.kt)("li",{parentName:"ul"},"while multiple process (or threads) are performing I/O on the same open fd, a fd's readiness may change between the time the fd was notified as being ready and the time of the subsequent I/O call."),(0,l.kt)("li",{parentName:"ul"},"large block data writing may nevertheless block even after a level-triggered APIs such as ",(0,l.kt)("inlineCode",{parentName:"li"},"select()")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"poll()")," informs ready for writing."),(0,l.kt)("li",{parentName:"ul"},"level-triggered APIs can return spurious readiness notifications -- falsely inform ready. could be caused by a kernel bug or be expected behavior in an uncommon scenario.")),(0,l.kt)("h2",{id:"632-io-multiplexing"},"63.2 I/O Multiplexing"),(0,l.kt)("h3",{id:"6324-comparison-of-select-and-poll"},"63.2.4 comparison of ",(0,l.kt)("inlineCode",{parentName:"h3"},"select()")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"poll()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"fd_set")," for ",(0,l.kt)("inlineCode",{parentName:"li"},"select")," has a limit on the range of file descriptors, by default, it is 1024."),(0,l.kt)("li",{parentName:"ul"},"we must reinitialize fd_set arguments while using ",(0,l.kt)("inlineCode",{parentName:"li"},"select()")," because they are value-result."),(0,l.kt)("li",{parentName:"ul"},"the ",(0,l.kt)("em",{parentName:"li"},"timeout")," precision is different between ",(0,l.kt)("inlineCode",{parentName:"li"},"select()")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"poll()")),(0,l.kt)("li",{parentName:"ul"},"if one of the file descriptors being monitored was closed, ",(0,l.kt)("inlineCode",{parentName:"li"},"poll()")," informs exactly which one, but ",(0,l.kt)("inlineCode",{parentName:"li"},"select()")," not.")),(0,l.kt)("h4",{id:"portability"},"Portability"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"select")," was more widely available than ",(0,l.kt)("inlineCode",{parentName:"p"},"poll")),(0,l.kt)("h4",{id:"performance"},"Performance"),(0,l.kt)("p",null,"The performance is similar is either is true:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"file descriptors to be monitored is small."),(0,l.kt)("li",{parentName:"ul"},"a large number of file descriptors are being monitored, but they are densely packed.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"poll")," can perform better than ",(0,l.kt)("inlineCode",{parentName:"p"},"select")," if the set of file descriptors to be monitored is sparse"),(0,l.kt)("h3",{id:"6325-problems-with-select-and-poll"},"63.2.5 Problems with ",(0,l.kt)("inlineCode",{parentName:"h3"},"select()")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"poll()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"On each call of them, the kernel must check all of the specified file descriptors to see if they are ready."),(0,l.kt)("li",{parentName:"ul"},"In each call of them, the program must pass a data structure to the kernel describing all the file descriptors to be monitored, and then the kernel returns a modified version."),(0,l.kt)("li",{parentName:"ul"},"After the call of them, the program must inspect every element of the retured data structure to see which file descriptors are ready.")),(0,l.kt)("h2",{id:"633-signal-driven-io"},"63.3 Signal-Driven I/O"),(0,l.kt)("p",null,"steps:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Establish a handler for the signal delivered by the signal-driven I/O mechanism. By default, SIGIO."),(0,l.kt)("li",{parentName:"ol"},"set /owner/ of the file descriptor.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"fcntl(fd, F_SETOWN, pid);\n")),(0,l.kt)("ol",{start:3},(0,l.kt)("li",{parentName:"ol"},"Enable nonblocking I/O by setting the ",(0,l.kt)("em",{parentName:"li"},"O_NONBLOCK")," open file status flag."),(0,l.kt)("li",{parentName:"ol"},"Enable signal-driven I/O by turning on the ",(0,l.kt)("em",{parentName:"li"},"O_ASYNC")," open file status flag.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"flags = fcntl(fd, F_GETFL);\nfcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);\n")),(0,l.kt)("ol",{start:5},(0,l.kt)("li",{parentName:"ol"},"When I/O becomes possible, the kernel generates a signal for the process and invokes the signal handler established in step 1."),(0,l.kt)("li",{parentName:"ol"},"edge-triggered notification.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'Example program\n+include: "Chapter63/demo_sigio.c" src c')),(0,l.kt)("h3",{id:"6331-when-is-io-possible-signaled"},'63.3.1 When Is "I/O Possible" Signaled?'),(0,l.kt)("h4",{id:"terminals-and-pseudoterminals"},"Terminals and pseudoterminals"),(0,l.kt)("h2",{id:"634-the-epoll-api"},"63.4 The ",(0,l.kt)("em",{parentName:"h2"},"epoll")," API"),(0,l.kt)("p",null,"primary advantages:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"much better than ",(0,l.kt)("inlineCode",{parentName:"li"},"select")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"poll")," when monitoring large numbers of file descriptors"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"epoll")," permits either level-triggered or edge-triggered notification.")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"epoll")," has some advantages over signal-driven I/O:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"avoid complexities of signal handling."),(0,l.kt)("li",{parentName:"ul"},"greater flexibility in specifying what kind of monitoring we want to perform.")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The ",(0,l.kt)("em",{parentName:"em"},"epoll")," API is Linux-specific (kqueue on MacOS), and is new in Linux 2.6")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"epoll instance"),", the central data structure, is a handle for kernel data structures that serve two purposes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"recording a list of file descriptors that this process has declared an interest in monitoring - the ",(0,l.kt)("em",{parentName:"li"},"interest list"),"."),(0,l.kt)("li",{parentName:"ul"},"maintaining a list of file descriptors that are ready for I/O - the ",(0,l.kt)("em",{parentName:"li"},"ready list"),".")),(0,l.kt)("p",null,"The membership of the ready list is a ",(0,l.kt)("em",{parentName:"p"},"subset")," of the interest list."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"epoll")," API consists of three system calls."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"epoll_create()")," system call creates an ",(0,l.kt)("em",{parentName:"li"},"epoll")," instance and returns a file descriptor referring to the instance."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"epoll_ctl()")," system call manipulates the interest list associated with an ",(0,l.kt)("em",{parentName:"li"},"epoll")," instance."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"epoll_wait()")," system call returns items from the ready list associated with an ",(0,l.kt)("em",{parentName:"li"},"epoll")," instance.")),(0,l.kt)("h3",{id:"6341-creating-an-epoll-instance-epoll_create"},"63.4.1 Creating an ",(0,l.kt)("em",{parentName:"h3"},"epoll")," instance: ",(0,l.kt)("inlineCode",{parentName:"h3"},"epoll_create()")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"include <sys/epoll.h>\n\n/**\n * @brief      create a new epoll instance\n *\n * @param      size     specifies the number of file descriptors that we expect to monitor\n *\n * @return     file descriptor on success, or -1 on error\n */\nint epoll_create(int size);\n")),(0,l.kt)("h3",{id:"6342-modifying-the-epoll-interest-list-epoll_ctrl"},"63.4.2 Modifying the ",(0,l.kt)("em",{parentName:"h3"},"epoll")," Interest List: ",(0,l.kt)("inlineCode",{parentName:"h3"},"epoll_ctrl()")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"include <sys/epoll.h>\n\n/**\n * @brief      modifies the interest list of the _epoll_ instance\n *\n * @details    detailed description\n *\n * @param      epfd     refered by\n * @param      op       EPOLL_CTRL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL\n * @param      ev       man epoll_ctl for details\n *\n * @return     0 on success, -1 on error\n */\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *ev);\n")),(0,l.kt)("p",null,"+caption: Using ",(0,l.kt)("inlineCode",{parentName:"p"},"epoll_create()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"epoll_ctl()")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'int epfd;\nstruct epoll_event ev;\n\nepfd = epoll_create(5);\nif (epfd `` -1) {\n        err_sys("epoll_create");\n}\n\nev.data.fd = fd;\nev.events = EPOLLIN;\nif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) `` -1) {\n        err_sys("epoll_ctl");\n}\n')),(0,l.kt)("h3",{id:"6343-waiting-for-events-epoll_wait"},"63.4.3 Waiting for Events: ",(0,l.kt)("inlineCode",{parentName:"h3"},"epoll_wait()")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"include <sys/epoll.h>\n\n/**\n  * @brief      returns info about ready file descriptors\n  *\n  * @details    from the epoll instance refered to by the file descriptor epfd.\n  *\n  * @return     number of ready fd if OK, 0 on timeout, -1 on error.\n  */\nint epoll_wait(int epfd, struct epoll_event *evlist, int maxevents, int timeout);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"EPOLLONESHOT")," flag\nFor specify to be notified only once about a particular file descriptor. Reenable by using the ",(0,l.kt)("inlineCode",{parentName:"p"},"epoll_ctl()")," ",(0,l.kt)("inlineCode",{parentName:"p"},"EPOLL_CTL_MOD")," operation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'Example program\n+caption: Listing 63-5: Using the epoll API\n+include: "Chapter63/epoll_input.c" src c'))))}c.isMDXComponent=!0}}]);